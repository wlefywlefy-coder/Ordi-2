# -*- coding: utf-8 -*-
import requests
import pandas as pd
import numpy as np
import time
import datetime as dt

# =========================================================
# 1) Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª â€“ Ù†Ù…Ø· Ù…Ø¶Ø§Ø±Ø¨ Ù‡Ø¬ÙˆÙ…ÙŠ
# =========================================================
BINANCE_API_URL = 'https://api.binance.com/api/v3'
SYMBOLS = ['LPTUSDT', 'ORDIUSDT']

ATR_PERIOD = 14
ATR_MULTIPLIER_SL = 0.8     # ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø© Ù…Ø¶Ø§Ø±Ø¨ (Ø£Ø¶ÙŠÙ‚)
VOL_MULTIPLIER = 1.2        # Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚
RSI_BREAKOUT_THRESHOLD = 48 # Ø²Ø®Ù… Ù…Ø¨ÙƒØ± Ù„Ù„Ù…Ø¶Ø§Ø±Ø¨
UPTREND_NEAR_RATIO = 0.98   # Ø³Ù…Ø§Ø­ Ø¨Ø§Ù†Ø¹ÙƒØ§Ø³ Ù…Ø¨ÙƒØ±: SMA20 >= 0.98 * EMA50
BODY_ATR_FACTOR = 0.4       # Ø¬Ø³Ù… Ø´Ù…Ø¹Ø© Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ â‰¥ 0.4*ATR

# Ù…Ø³ØªÙˆÙŠØ§Øª Ù…Ø­ÙˆØ±ÙŠØ© ÙŠØ¯ÙˆÙŠØ© (ØªÙ‚Ø¯Ø± ØªØºÙŠÙ‘Ø±Ù‡Ø§)
PIVOT_LEVELS = {
    'LPTUSDT': 5.20,
    'ORDIUSDT': 4.12
}

# Ø¢Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª
TRADING_STATES = {
    sym: {
        'state': 'WAITING',
        'entry_price': 0.0,
        'stop_loss': 0.0,
        'target_1R': 0.0,
        'pivot': PIVOT_LEVELS[sym]
    } for sym in SYMBOLS
}

# Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ù„Ø·Ø¨Ø§Ø¹Ø© Ø£ÙˆØ¶Ø­
HEAD = {
    "WAITING": "ğŸš¶",
    "SCOUT": "ğŸŸ ",
    "ARMED": "âš”ï¸",
    "BREAKOUT": "ğŸš€",
    "FAKEOUT": "â›”",
    "LONG": "ğŸŸ¢",
    "EXIT": "ğŸ›‘",
    "MANAGE": "âœ…"
}

# =========================================================
# 2) Ù…Ø¤Ø´Ø±Ø§Øª
# =========================================================
def calculate_sma(df, period):
    df[f'SMA_{period}'] = df['close'].rolling(window=period).mean()
    return df

def calculate_ema(df, period):
    df[f'EMA_{period}'] = df['close'].ewm(span=period, adjust=False).mean()
    return df

def calculate_rsi(df, period=14):
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    return df

def calculate_atr(df, period=14):
    hl = df['high'] - df['low']
    hc = (df['high'] - df['close'].shift(1)).abs()
    lc = (df['low'] - df['close'].shift(1)).abs()
    tr = pd.concat([hl, hc, lc], axis=1).max(axis=1)
    df['ATR'] = tr.ewm(span=period, adjust=False).mean()
    return df

# =========================================================
# 3) Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø¨ÙŠÙ†Ø§Ù†Ø³ (Requests Ù…Ø¨Ø§Ø´Ø±Ø©)
# =========================================================
def fetch_ohlcv(symbol, interval, limit=200):
    try:
        url = f"{BINANCE_API_URL}/klines"
        params = {'symbol': symbol, 'interval': interval, 'limit': limit}
        r = requests.get(url, params=params, timeout=10)
        r.raise_for_status()
        data = r.json()
        df = pd.DataFrame(data, columns=[
            'timestamp','open','high','low','close','volume',
            'c1','c2','c3','c4','c5','c6'
        ])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        for col in ['open','high','low','close','volume']:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        df = df[['timestamp','open','high','low','close','volume']].dropna()
        df.set_index('timestamp', inplace=True)
        return df
    except Exception:
        return pd.DataFrame()

def analyze_liquidity(symbol, depth_limit=100):
    """Ø¥Ø±Ø¬Ø§Ø¹ Ø£ÙØ¶Ù„ Ø³Ø¹Ø± Ø­Ø§Ù„Ù (Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒØªØ§Ø¨ Ø§Ù„Ø£ÙˆØ§Ù…Ø±)"""
    try:
        url = f"{BINANCE_API_URL}/depth"
        params = {'symbol': symbol, 'limit': depth_limit}
        r = requests.get(url, params=params, timeout=10)
        r.raise_for_status()
        ob = r.json()
        asks = ob.get('asks', [])
        bids = ob.get('bids', [])
        best_ask = float(asks[0][0]) if asks else None
        best_bid = float(bids[0][0]) if bids else None
        if best_ask and best_bid:
            return (best_ask + best_bid) / 2.0
        return best_ask or best_bid
    except Exception:
        return None

def get_market_data(symbol):
    data = {}

    # 15m â€“ Ø¥Ø·Ø§Ø± Ø§Ù„ØªÙ†ÙÙŠØ°
    df15 = fetch_ohlcv(symbol, '15m', limit=120)
    if df15.empty: return None
    df15 = calculate_sma(df15, 20)
    df15 = calculate_ema(df15, 50)
    df15 = calculate_rsi(df15, 14)
    df15 = calculate_atr(df15, ATR_PERIOD)
    data['df15'] = df15

    # 4h â€“ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù…
    df4h = fetch_ohlcv(symbol, '4h', limit=80)
    if df4h.empty: return None
    df4h = calculate_sma(df4h, 20)
    df4h = calculate_ema(df4h, 50)
    data['df4h'] = df4h

    # Ø³Ø¹Ø± Ù„Ø­Ø¸ÙŠ
    px = analyze_liquidity(symbol, 100)
    if px is None: return None
    data['price'] = px

    return data

# =========================================================
# 4) Ù…Ø­Ø±Ùƒ Ø§Ù„Ù€ ATS (Ù…Ø¶Ø§Ø±Ø¨ Ù‡Ø¬ÙˆÙ…ÙŠ)
# =========================================================
def ats_engine(symbol, data):
    if data is None:
        return ("WAITING", {'reason': 'No data'}, None)

    s = TRADING_STATES[symbol]
    pivot = s['pivot']

    df15 = data['df15'];  df4h = data['df4h'];  price = data['price']

    close15 = df15['close'].iloc[-1]
    prev_close15 = df15['close'].iloc[-2]
    open15 = df15['open'].iloc[-1]
    vol15 = df15['volume'].iloc[-1]
    avg_vol15 = df15['volume'].tail(20).mean()
    atr15 = df15['ATR'].iloc[-1]
    rsi15 = df15['RSI'].iloc[-1]

    sma20_4h = df4h['SMA_20'].iloc[-1]
    ema50_4h = df4h['EMA_50'].iloc[-1]

    # Ø´Ø±ÙˆØ· Ù…Ø¶Ø§Ø±Ø¨
    is_uptrend_near = (sma20_4h >= UPTREND_NEAR_RATIO * ema50_4h)  # Ø§Ù†Ø¹ÙƒØ§Ø³ Ù‚Ø±ÙŠØ¨
    is_momentum = (rsi15 >= RSI_BREAKOUT_THRESHOLD)
    body_len = abs(close15 - open15)
    body_ok = (body_len >= BODY_ATR_FACTOR * atr15)
    vol_ok = (vol15 >= VOL_MULTIPLIER * avg_vol15)

    # Ù„Ù…Ø³/Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ù…Ø­ÙˆØ±
    touched_pivot = (df15['high'].iloc[-1] >= pivot)
    break_candle = (close15 > pivot) and (prev_close15 <= pivot)

    state = s['state']

    # ========= Ø¥Ø¯Ø§Ø±Ø© ØµÙÙ‚Ø© Ù…ÙØªÙˆØ­Ø© =========
    if state == 'LONG':
        sl = s['stop_loss']; tp1 = s['target_1R']; entry = s['entry_price']
        # ÙˆÙ‚Ù
        if price <= sl:
            s['state'] = 'WAITING'
            return ("EXIT", {'reason': f'Hit SL {sl:.4f}'}, None)
        # Ù†Ù‚Ù„ ÙˆÙ‚Ù Ù„Ù„ØªØ¹Ø§Ø¯Ù„ Ø¨Ø¹Ø¯ 1R
        if price >= tp1 and sl != entry:
            s['stop_loss'] = entry
            return ("MANAGE", {'reason':'TP1 hit â†’ SL to BE', 'new_sl': entry}, None)
        # ÙØ´Ù„ Ø§Ø®ØªØ±Ø§Ù‚ (Ø±Ø¬Ø¹ ØªØ­Øª Ø§Ù„Ù…Ø­ÙˆØ± Ø¨Ø­Ø¬Ù…/Ø¬Ø³Ù… Ù…Ø¹ØªØ¨Ø±)
        if (close15 < pivot and vol_ok and body_ok):
            s['state'] = 'WAITING'
            return ("FAKEOUT", {'reason':'Break failed â€“ back under pivot'}, None)
        return ("LONG", {'info':'Active'}, None)

    # ========= ÙˆØ¶Ø¹ Ø§Ù†ØªØ¸Ø§Ø± =========
    if state == 'WAITING':
        # Ø§Ø³ØªØ·Ù„Ø§Ø¹ Ù…Ø¨ÙƒØ± Ù„Ùˆ ØªØ­Ù‚Ù‚ Ø´Ø±Ø·Ø§Ù† Ù…Ù† Ø«Ù„Ø§Ø«Ø©
        score = sum([is_uptrend_near, is_momentum, touched_pivot])
        if score >= 2:
            s['state'] = 'SCOUT'
            return ("SCOUT", {'reason':'Early setup (2/3 ready). Wait trigger.'}, None)
        return ("WAITING", {'reason':'Trend/Momentum not aligned'}, None)

    # ========= Ø§Ø³ØªØ·Ù„Ø§Ø¹ (Ù‡Ø¬ÙˆÙ…ÙŠ) =========
    if state == 'SCOUT':
        # Ù„Ùˆ ÙÙ‚Ø¯Ù†Ø§ Ù…ÙŠÙ„ Ø§Ù„ØªØ±Ù†Ø¯ â†’ Ø±Ø¬ÙˆØ¹ Ø§Ù†ØªØ¸Ø§Ø±
        if not is_uptrend_near:
            s['state'] = 'WAITING'
            return ("WAITING", {'reason':'Lost 4h near-trend'}, None)

        # Ø¯Ø®ÙˆÙ„ Ø§Ø®ØªØ±Ø§Ù‚ Ù…Ø¨ÙƒØ±
        if break_candle and body_ok and vol_ok:
            risk = ATR_MULTIPLIER_SL * atr15
            sl = close15 - risk
            tp1 = close15 + risk

            s['state'] = 'LONG'
            s['entry_price'] = float(close15)
            s['stop_loss'] = float(sl)
            s['target_1R'] = float(tp1)

            return ("BREAKOUT", {
                'entry': round(close15, 4),
                'sl': round(sl, 4),
                'tp1': round(tp1, 4),
                'risk': round(risk, 4),
                'pivot': pivot
            }, None)

        # Ù„Ø³Ù‡ Ù…Ø§ ØªØ£ÙƒØ¯ Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚
        return ("SCOUT", {'reason':'Armed & near. Waiting breakout.'}, None)

    return ("WAITING", {'reason':'Fallback'}, None)

# =========================================================
# 5) Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ´ØºÙŠÙ„
# =========================================================
if __name__ == "__main__":
    try:
        while True:
            now = dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            print("\n" + "#"*90)
            print(f"ğŸ”„ ATS SCANNER (Aggressive Trader) | {now}")
            print("#"*90)

            for sym in SYMBOLS:
                data = get_market_data(sym)
                signal, details, _ = ats_engine(sym, data)
                st = TRADING_STATES[sym]['state']
                icon = HEAD.get(signal, "â„¹ï¸")
                print(f"\nâ€” {icon} {sym} | STATE: {st} â€”")
                if details:
                    for k,v in details.items():
                        print(f"  â€¢ {k}: {v}")
                # Ø·Ø¨Ø§Ø¹Ø© Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚
                if signal == "BREAKOUT":
                    e = details['entry']; sl = details['sl']; tp1 = details['tp1']
                    print(f"  â–¶ Entry {e} | SL {sl} | TP1 {tp1}")

            print("\n" + "="*90)
            time.sleep(15)  # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 15 Ø«Ø§Ù†ÙŠØ©
    except KeyboardInterrupt:
        print("\nTerminated by user.")
    except Exception as e:
        print(f"\nFATAL ERROR: {e}")